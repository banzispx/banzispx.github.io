<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深拷贝和浅拷贝的定义 | SPX Interview</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.3f949b7f.css" as="style"><link rel="preload" href="/assets/js/app.a611df23.js" as="script"><link rel="preload" href="/assets/js/2.1379642d.js" as="script"><link rel="preload" href="/assets/js/19.0f8d6009.js" as="script"><link rel="prefetch" href="/assets/js/10.beeb90b4.js"><link rel="prefetch" href="/assets/js/11.e3a6abb8.js"><link rel="prefetch" href="/assets/js/12.0eec26a8.js"><link rel="prefetch" href="/assets/js/13.03b3daac.js"><link rel="prefetch" href="/assets/js/14.d2676b0f.js"><link rel="prefetch" href="/assets/js/15.95f91391.js"><link rel="prefetch" href="/assets/js/16.6c8ef939.js"><link rel="prefetch" href="/assets/js/17.cd84e178.js"><link rel="prefetch" href="/assets/js/18.8414afbf.js"><link rel="prefetch" href="/assets/js/20.6242501c.js"><link rel="prefetch" href="/assets/js/21.1c10ab44.js"><link rel="prefetch" href="/assets/js/22.86227233.js"><link rel="prefetch" href="/assets/js/23.d45bb3c2.js"><link rel="prefetch" href="/assets/js/24.d15fc351.js"><link rel="prefetch" href="/assets/js/25.444dea07.js"><link rel="prefetch" href="/assets/js/26.90a762cd.js"><link rel="prefetch" href="/assets/js/27.2bec70a5.js"><link rel="prefetch" href="/assets/js/28.5f7e4e30.js"><link rel="prefetch" href="/assets/js/29.31679bc1.js"><link rel="prefetch" href="/assets/js/3.1de297b1.js"><link rel="prefetch" href="/assets/js/30.1a59e853.js"><link rel="prefetch" href="/assets/js/31.73e3f38b.js"><link rel="prefetch" href="/assets/js/4.ae2b9088.js"><link rel="prefetch" href="/assets/js/5.bcea38fb.js"><link rel="prefetch" href="/assets/js/6.82007b79.js"><link rel="prefetch" href="/assets/js/7.49cb7827.js"><link rel="prefetch" href="/assets/js/8.5c3efea6.js"><link rel="prefetch" href="/assets/js/9.0c1ca9b3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3f949b7f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">SPX Interview</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/http/" class="nav-link">
  Interview
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Frame</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/react/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/banzispx/vuePress" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/http/" class="nav-link">
  Interview
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Frame</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/react/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/banzispx/vuePress" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTTP</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/http/" class="sidebar-link">基础</a></li><li><a href="/http/url.html" class="sidebar-link">从url到页面渲染</a></li><li><a href="/http/https.html" class="sidebar-link">https</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML/CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/html-css/html.html" class="sidebar-link">html</a></li><li><a href="/html-css/maincss.html" class="sidebar-link">css</a></li><li><a href="/html-css/cssCode.html" class="sidebar-link">css代码</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/base.html" class="sidebar-link">基础</a></li><li><a href="/js/rumen.html" class="sidebar-link">入门</a></li><li><a href="/js/middle.html" class="sidebar-link">源码</a></li><li><a href="/js/axios.html" class="sidebar-link">axios</a></li><li><a href="/js/deepclone.html" aria-current="page" class="active sidebar-link">deepclone</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/deepclone.html#深拷贝和浅拷贝的定义" class="sidebar-link">深拷贝和浅拷贝的定义</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#乞丐版" class="sidebar-link">乞丐版</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#基础版本" class="sidebar-link">基础版本</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#考虑数组" class="sidebar-link">考虑数组</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#循环引用" class="sidebar-link">循环引用</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#性能优化" class="sidebar-link">性能优化</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#其他数据类型" class="sidebar-link">其他数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/deepclone.html#合理的判断引用类型" class="sidebar-link">合理的判断引用类型</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#获取数据类型" class="sidebar-link">获取数据类型</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#可继续遍历的类型" class="sidebar-link">可继续遍历的类型</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#不可继续遍历的类型" class="sidebar-link">不可继续遍历的类型</a></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#克隆函数" class="sidebar-link">克隆函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/js/deepclone.html#最后" class="sidebar-link">最后</a></li></ul></li><li><a href="/js/promise.html" class="sidebar-link">promise</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="深拷贝和浅拷贝的定义"><a href="#深拷贝和浅拷贝的定义" class="header-anchor">#</a> 深拷贝和浅拷贝的定义</h2> <p>https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg
我们来明确一下深拷贝和浅拷贝的定义：</p> <p>浅拷贝：</p> <blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote> <p>深拷贝：</p> <blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote> <p>话不多说，浅拷贝就不再多说，下面我们直入正题：</p> <h2 id="乞丐版"><a href="#乞丐版" class="header-anchor">#</a> 乞丐版</h2> <p>在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。</p> <div class="language- extra-class"><pre class="language-text"><code>JSON.parse(JSON.stringify());
</code></pre></div><p>这种写法非常简单，而且可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况。</p> <p>显然，面试时你只说出这样的方法是一定不会合格的。</p> <p>接下来，我们一起来手动实现一个深拷贝方法。</p> <h2 id="基础版本"><a href="#基础版本" class="header-anchor">#</a> 基础版本</h2> <p>如果是浅拷贝的话，我们可以很容易写出下面的代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function clone(target) {    
  let cloneTarget = {};    
  for (const key in target) {        
    cloneTarget[key] = target[key];    
  }    
  return cloneTarget;};
</code></pre></div><p>创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。</p> <p>如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，稍微改写上面的代码：</p> <ul><li>如果是原始类型，无需继续拷贝，直接返回</li> <li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行<strong>深拷贝后</strong>依次添加到新对象上。</li></ul> <p>很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型，这样我们就完成了一个最简单的深拷贝：</p> <div class="language- extra-class"><pre class="language-text"><code>    function clone(target) {
        if (typeof target === 'object') {
            let cloneTarget = {};
            for (const key in target) {
                cloneTarget[key] = clone(target[key]);
            }
            return cloneTarget;
        } else {
            return target;
        }
    };
</code></pre></div><p>这是一个最基础版本的深拷贝，这段代码可以让你向面试官展示你可以用递归解决问题，但是显然，他还有非常多的缺陷，比如，还没有考虑数组。</p> <h2 id="考虑数组"><a href="#考虑数组" class="header-anchor">#</a> 考虑数组</h2> <p>在上面的版本中，我们的初始化结果只考虑了普通的 <code>object</code>，下面我们只需要把初始化代码稍微一变，就可以兼容数组了：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = function clone(target) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
</code></pre></div><p>在clone2.test.js中执行下面的测试用例：</p> <div class="language- extra-class"><pre class="language-text"><code>const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8]
};
target.target = target;

</code></pre></div><p>OK，没有问题，你的代码又向合格迈进了一小步。</p> <h2 id="循环引用"><a href="#循环引用" class="header-anchor">#</a> 循环引用</h2> <p>我们执行下面这样一个测试用例：</p> <div class="language- extra-class"><pre class="language-text"><code>const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8]
};
target.target = target;
</code></pre></div><p>很明显，因为递归进入死循环导致栈内存溢出了。</p> <p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接的引用了自身的情况：
解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p> <p>这个存储空间，需要可以存储 <code>key-value</code>形式的数据，且 <code>key</code>可以是一个引用类型，我们可以选择 <code>Map</code>这种数据结构：</p> <ul><li>检查<code>map</code>中有无克隆过的对象</li> <li>有 - 直接返回</li> <li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li> <li>继续克隆</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function clone(target, map = new Map()) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        if (map.get(target)) {
            return target;
        }
        map.set(target, cloneTarget);
        for (const key in target) {
            cloneTarget[key] = clone(target[key], map);
        }
        return cloneTarget;
    } else {
        return target;
    }
};

</code></pre></div><p>再来执行上面的测试用例：</p> <img src="/js/circular.png" alt="mixureSecure"> <p>可以看到，执行没有报错，且 <code>target</code>属性，变为了一个 <code>Circular</code>类型，即循环应用的意思。</p> <p>接下来，我们可以使用， <code>WeakMap</code>提代 <code>Map</code>来使代码达到画龙点睛的作用。</p> <div class="language- extra-class"><pre class="language-text"><code>function clone(target, map = new WeakMap()) {    // ...};
</code></pre></div><p>为什么要这样做呢？，先来看看 <code>WeakMap</code>的作用：</p> <blockquote><p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p></blockquote> <p>什么是弱引用呢？</p> <blockquote><p>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。</p></blockquote> <p>我们默认创建一个对象：<code>constobj={}</code>，就默认创建了一个强引用的对象，我们只有手动将 <code>obj=null</code>，它才会被垃圾回收机制进行回收，如果是弱引用对象，垃圾回收机制会自动帮我们回收。</p> <p>举个例子：</p> <p>如果我们使用 <code>Map</code>的话，那么对象间是存在强引用关系的：</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = { name : 'ConardLi'}const target = {    obj:'code秘密花园'}obj = null;
</code></pre></div><p>虽然我们手动将 <code>obj</code>，进行释放，然是 <code>target</code>依然对 <code>obj</code>存在强引用关系，所以这部分内存依然无法被释放。</p> <p>再来看 <code>WeakMap</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = { name : 'ConardLi'}const target = new WeakMap();target.set(obj,'code秘密花园');obj = null;
</code></pre></div><p>如果是 <code>WeakMap</code>的话， <code>target</code>和 <code>obj</code>存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。</p> <p>设想一下，如果我们要拷贝的对象非常庞大时，使用 <code>Map</code>会对内存造成非常大的额外消耗，而且我们需要手动清除 <code>Map</code>的属性才能释放这块内存，而 <code>WeakMap</code>会帮我们巧妙化解这个问题。</p> <p>我也经常在某些代码中看到有人使用 <code>WeakMap</code>来解决循环引用问题，但是解释都是模棱两可的，当你不太了解 <code>WeakMap</code>的真正作用时。我建议你也不要在面试中写这样的代码，结果只能是给自己挖坑，即使是准备面试，你写的每一行代码也都是需要经过深思熟虑并且非常明白的。</p> <p>能考虑到循环引用的问题，你已经向面试官展示了你考虑问题的全面性，如果还能用 <code>WeakMap</code>解决问题，并很明确的向面试官解释这样做的目的，那么你的代码在面试官眼里应该算是合格了。</p> <h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <p>在上面的代码中，我们遍历数组和对象都使用了 <code>forin</code>这种方式，实际上 <code>forin</code>在遍历时效率是非常低的，我们来对比下常见的三种循环 <code>for、while、forin</code>的执行效率：</p> <img src="/js/xingneng.png" alt="mixureSecure"> <p>可以看到， <code>while</code>的效率是最好的，所以，我们可以想办法把 <code>forin</code>遍历改变为 <code>while</code>遍历。</p> <p>我们先使用 <code>while</code>来实现一个通用的 <code>forEach</code>遍历， <code>iteratee</code>是遍历的回掉函数，他可以接收每次遍历的 <code>value</code>和 <code>index</code>两个参数：</p> <div class="language- extra-class"><pre class="language-text"><code>function forEach(array, iteratee) {
    let index = -1;
    const length = array.length;
    while (++index &lt; length) {
        iteratee(array[index], index);
    }
    return array;
}
</code></pre></div><p>下面对我们的 <code>cloen</code>函数进行改写：当遍历数组时，直接使用 <code>forEach</code>进行遍历，当遍历对象时，使用 <code>Object.keys</code>取出所有的 <code>key</code>进行遍历，然后在遍历时把 <code>forEach</code>会调函数的 <code>value</code>当作 <code>key</code>使用：</p> <div class="language- extra-class"><pre class="language-text"><code>function clone(target, map = new WeakMap()) {
    if (typeof target === 'object') {
        const isArray = Array.isArray(target);
        let cloneTarget = isArray ? [] : {};

        if (map.get(target)) {
            return target;
        }
        map.set(target, cloneTarget);

        const keys = isArray ? undefined : Object.keys(target);
        forEach(keys || target, (value, key) =&gt; {
            if (keys) {
                key = value;
            }
            cloneTarget[key] = clone2(target[key], map);
        });

        return cloneTarget;
    } else {
        return target;
    }
}

</code></pre></div><p>下面，我们执行clone4.test.js分别对上一个克隆函数和改写后的克隆函数进行测试：</p> <div class="language- extra-class"><pre class="language-text"><code>const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8],
    f: { f: { f: { f: { f: { f: { f: { f: { f: { f: { f: { f: {} } } } } } } } } } } },
};

target.target = target;

console.time();
const result = clone1(target);
console.timeEnd();

console.time();
const result2 = clone2(target);
console.timeEnd();
</code></pre></div><p>执行结果：</p> <p>.5ms .1ms</p> <p>很明显，我们的性能优化是有效的。</p> <p>到这里，你已经向面试官展示了，在写代码的时候你会考虑程序的运行效率，并且你具有通用函数的抽象能力。</p> <h2 id="其他数据类型"><a href="#其他数据类型" class="header-anchor">#</a> 其他数据类型</h2> <p>在上面的代码中，我们其实只考虑了普通的 <code>object</code>和 <code>array</code>两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。</p> <h3 id="合理的判断引用类型"><a href="#合理的判断引用类型" class="header-anchor">#</a> 合理的判断引用类型</h3> <p>首先，判断是否为引用类型，我们还需要考虑 <code>function</code>和 <code>null</code>两种特殊的数据类型：</p> <div class="language- extra-class"><pre class="language-text"><code>function isObject(target) {
    const type = typeof target;
    return target !== null &amp;&amp; (type === 'object' || type === 'function');
}
    if (!isObject(target)) {
        return target;
    }

</code></pre></div><h3 id="获取数据类型"><a href="#获取数据类型" class="header-anchor">#</a> 获取数据类型</h3> <p>我们可以使用 <code>toString</code>来获取准确的引用类型：</p> <blockquote><p>每一个引用类型都有 <code>toString</code>方法，默认情况下， <code>toString()</code>方法被每个 <code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，t <code>oString()</code>返回 <code>&quot;[object type]&quot;</code>，其中type是对象的类型。</p></blockquote> <p>注意，上面提到了如果此方法在自定义对象中未被覆盖， <code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如 <code>Array、Date、RegExp</code>等都重写了 <code>toString</code>方法。</p> <p>我们可以直接调用 <code>Object</code>原型上未被覆盖的 <code>toString()</code>方法，使用 <code>call</code>来改变 <code>this</code>指向来达到我们想要的效果。</p> <div class="language- extra-class"><pre class="language-text"><code>function getType(target) {    
  return Object.prototype.toString.call(target);
}
</code></pre></div><img src="/js/toString.png" alt="mixureSecure"> <p>下面我们抽离出一些常用的数据类型以便后面使用：</p> <div class="language- extra-class"><pre class="language-text"><code>const mapTag = '[object Map]';
const setTag = '[object Set]';
const arrayTag = '[object Array]';const objectTag = '[object Object]';
const boolTag = '[object Boolean]';const dateTag = '[object Date]';
const errorTag = '[object Error]';const numberTag = '[object Number]';
const regexpTag = '[object RegExp]';const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
</code></pre></div><p>在上面的集中类型中，我们简单将他们分为两类：</p> <ul><li>可以继续遍历的类型</li> <li>不可以继续遍历的类型</li></ul> <p>我们分别为它们做不同的拷贝。</p> <h3 id="可继续遍历的类型"><a href="#可继续遍历的类型" class="header-anchor">#</a> 可继续遍历的类型</h3> <p>上面我们已经考虑的 <code>object</code>、 <code>array</code>都属于可以继续遍历的类型，因为它们内存都还可以存储其他数据类型的数据，另外还有 <code>Map</code>， <code>Set</code>等都是可以继续遍历的类型，这里我们只考虑这四种，如果你有兴趣可以继续探索其他类型。</p> <p>有序这几种类型还需要继续进行递归，我们首先需要获取它们的初始化数据，例如上面的 <code>[]</code>和 <code>{}</code>，我们可以通过拿到 <code>constructor</code>的方式来通用的获取。</p> <p>例如：<code>consttarget={}</code>就是 <code>consttarget=newObject()</code>的语法糖。另外这种方法还有一个好处：因为我们还使用了原对象的构造方法，所以它可以保留对象原型上的数据，如果直接使用普通的 <code>{}</code>，那么原型必然是丢失了的。</p> <div class="language- extra-class"><pre class="language-text"><code>function getInit(target) {    
  const Ctor = target.constructor;    
  return new Ctor();
}
</code></pre></div><p>下面，我们改写 <code>clone</code>函数，对可继续遍历的数据类型进行处理：</p> <div class="language- extra-class"><pre class="language-text"><code>function clone(target, map = new WeakMap()) {

    // 克隆原始类型
    if (!isObject(target)) {
        return target;
    }

    // 初始化
    const type = getType(target);
    let cloneTarget;
    if (deepTag.includes(type)) {
        cloneTarget = getInit(target, type);
    }

    // 防止循环引用
    if (map.get(target)) {
        return target;
    }
    map.set(target, cloneTarget);

    // 克隆set
    if (type === setTag) {
        target.forEach(value =&gt; {
            cloneTarget.add(clone(value));
        });
        return cloneTarget;
    }

    // 克隆map
    if (type === mapTag) {
        target.forEach((value, key) =&gt; {
            cloneTarget.set(key, clone(value));
        });
        return cloneTarget;
    }

    // 克隆对象和数组
    const keys = type === arrayTag ? undefined : Object.keys(target);
    forEach(keys || target, (value, key) =&gt; {
        if (keys) {
            key = value;
        }
        cloneTarget[key] = clone(target[key], map);
    });

    return cloneTarget;
}

</code></pre></div><p>我们执行clone5.test.js对下面的测试用例进行测试：</p> <div class="language- extra-class"><pre class="language-text"><code>const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8],
    empty: null,
    map,
    set,
};

</code></pre></div><p>执行结果：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x0ocaqyO4ciaNVlImEC8SJEzK8cumyNpibr32WmswbFnrTV1aEYZnl7oNicpCefAibHUyuZHR0nJNiaJVw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p> <p>没有问题，里大功告成又进一步，下面我们继续处理其他类型：</p> <h3 id="不可继续遍历的类型"><a href="#不可继续遍历的类型" class="header-anchor">#</a> 不可继续遍历的类型</h3> <p>其他剩余的类型我们把它们统一归类成不可处理的数据类型，我们依次进行处理：</p> <p><code>Bool</code>、 <code>Number</code>、 <code>String</code>、 <code>String</code>、 <code>Date</code>、 <code>Error</code>这几种类型我们都可以直接用构造函数和原始数据创建一个新对象：</p> <div class="language- extra-class"><pre class="language-text"><code>function cloneOtherType(targe, type) {
    const Ctor = targe.constructor;
    switch (type) {
        case boolTag:
        case numberTag:
        case stringTag:
        case errorTag:
        case dateTag:
            return new Ctor(targe);
        case regexpTag:
            return cloneReg(targe);
        case symbolTag:
            return cloneSymbol(targe);
        default:
            return null;
    }
}

</code></pre></div><p>克隆 <code>Symbol</code>类型：</p> <div class="language- extra-class"><pre class="language-text"><code>function cloneSymbol(targe) {
    return Object(Symbol.prototype.valueOf.call(targe));
}

克隆正则：

function cloneReg(targe) {
    const reFlags = /\w*$/;
    const result = new targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex = targe.lastIndex;
    return result;
}

</code></pre></div><p>实际上还有很多数据类型我这里没有写到，有兴趣的话可以继续探索实现一下。</p> <p>能写到这里，面试官已经看到了你考虑问题的严谨性，你对变量和类型的理解，对 <code>JS API</code>的熟练程度，相信面试官已经开始对你刮目相看了。</p> <h3 id="克隆函数"><a href="#克隆函数" class="header-anchor">#</a> 克隆函数</h3> <p>最后，我把克隆函数单独拎出来了，实际上克隆函数是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，我特意看了下 <code>lodash</code>对函数的处理：</p> <div class="language- extra-class"><pre class="language-text"><code> const isFunc = typeof value == 'function' if (isFunc || !cloneableTags[tag]) {        return object ? value : {} }
</code></pre></div><p>可见这里如果发现是函数的话就会直接返回了，没有做特殊的处理，但是我发现不少面试官还是热衷于问这个问题的，而且据我了解能写出来的少之又少。。。</p> <p>实际上这个方法并没有什么难度，主要就是考察你对基础的掌握扎实不扎实。</p> <p>首先，我们可以通过 <code>prototype</code>来区分下箭头函数和普通函数，箭头函数是没有 <code>prototype</code>的。</p> <p>我们可以直接使用 <code>eval</code>和函数字符串来重新生成一个箭头函数，注意这种方法是不适用于普通函数的。</p> <p>我们可以使用正则来处理普通函数：</p> <p>分别使用正则取出函数体和函数参数，然后使用 <code>newFunction([arg1[,arg2[,...argN]],]functionBody)</code>构造函数重新构造一个新的函数：</p> <div class="language- extra-class"><pre class="language-text"><code>function cloneFunction(func) {
    const bodyReg = /(?&lt;={)(.|\n)+(?=})/m;
    const paramReg = /(?&lt;=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    if (func.prototype) {
        console.log('普通函数');
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            console.log('匹配到函数体：', body[0]);
            if (param) {
                const paramArr = param[0].split(',');
                console.log('匹配到参数：', paramArr);
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}

</code></pre></div><p>最后，我们再来执行clone6.test.js对下面的测试用例进行测试：</p> <div class="language- extra-class"><pre class="language-text"><code>const map = new Map();
map.set('key', 'value');
map.set('ConardLi', 'code秘密花园');

const set = new Set();
set.add('ConardLi');
set.add('code秘密花园');

const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8],
    empty: null,
    map,
    set,
    bool: new Boolean(true),
    num: new Number(2),
    str: new String(2),
    symbol: Object(Symbol(1)),
    date: new Date(),
    reg: /\d+/,
    error: new Error(),
    func1: () =&gt; {
        console.log('code秘密花园');
    },
    func2: function (a, b) {
        return a + b;
    }
};

</code></pre></div><p>执行结果：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x0ocaqyO4ciaNVlImEC8SJEzaw9SxEejMiaUXSllOjMjXI4uy1icVEsfXxRojJyDxtZVtHDHk9nxrFFw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p> <h2 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h2> <p>为了更好的阅读，我们用一张图来展示上面所有的代码：
<img src="/js/deepclone.png" alt="mixureSecure"></p> <p>完整代码：https://github.com/ConardLi/ConardLi.github.io/blob/master/demo/deepClone/src/clone_6.js</p> <p>可见，一个小小的深拷贝还是隐藏了很多的知识点的。</p> <p>千万不要以最低的要求来要求自己，如果你只是为了应付面试中的一个题目，那么你可能只会去准备上面最简陋的深拷贝的方法。</p> <p>但是面试官考察你的目的是全方位的考察你的思维能力，如果你写出上面的代码，可以体现你多方位的能力：</p> <ul><li><p>基本实现</p></li> <li><ul><li>递归能力</li></ul></li> <li><p>循环引用</p></li> <li><ul><li>考虑问题的全面性</li> <li>理解weakmap的真正意义</li></ul></li> <li><p>多种类型</p></li> <li><ul><li>考虑问题的严谨性</li> <li>创建各种引用类型的方法，JS API的熟练程度</li> <li>准确的判断数据类型，对数据类型的理解程度</li></ul></li> <li><p>通用遍历：</p></li> <li><ul><li>写代码可以考虑性能优化</li> <li>了解集中遍历的效率</li> <li>代码抽象能力</li></ul></li> <li><p>拷贝函数：</p></li> <li><ul><li>箭头函数和普通函数的区别</li> <li>正则表达式熟练程度</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const mapTag = '[object Map]';
const setTag = '[object Set]';
const arrayTag = '[object Array]';
const objectTag = '[object Object]';
const argsTag = '[object Arguments]';

const boolTag = '[object Boolean]';
const dateTag = '[object Date]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];


function forEach(array, iteratee) {
    let index = -1;
    const length = array.length;
    while (++index &lt; length) {
        iteratee(array[index], index);
    }
    return array;
}

function isObject(target) {
    const type = typeof target;
    return target !== null &amp;&amp; (type === 'object' || type === 'function');
}

function getType(target) {
    return Object.prototype.toString.call(target);
}

function getInit(target) {
    const Ctor = target.constructor;
    return new Ctor();
}

function cloneSymbol(targe) {
    return Object(Symbol.prototype.valueOf.call(targe));
}

function cloneReg(targe) {
    const reFlags = /\w*$/;
    const result = new targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex = targe.lastIndex;
    return result;
}

function cloneFunction(func) {
    const bodyReg = /(?&lt;={)(.|\n)+(?=})/m;
    const paramReg = /(?&lt;=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    if (func.prototype) {
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            if (param) {
                const paramArr = param[0].split(',');
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}

function cloneOtherType(targe, type) {
    const Ctor = targe.constructor;
    switch (type) {
        case boolTag:
        case numberTag:
        case stringTag:
        case errorTag:
        case dateTag:
            return new Ctor(targe);
        case regexpTag:
            return cloneReg(targe);
        case symbolTag:
            return cloneSymbol(targe);
        case funcTag:
            return cloneFunction(targe);
        default:
            return null;
    }
}

function clone(target, map = new WeakMap()) {

    // 克隆原始类型
    if (!isObject(target)) {
        return target;
    }

    // 初始化
    const type = getType(target);
    let cloneTarget;
    if (deepTag.includes(type)) {
        cloneTarget = getInit(target, type);
    } else {
        return cloneOtherType(target, type);
    }

    // 防止循环引用
    if (map.get(target)) {
        return map.get(target);
    }
    map.set(target, cloneTarget);

    // 克隆set
    if (type === setTag) {
        target.forEach(value =&gt; {
            cloneTarget.add(clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆map
    if (type === mapTag) {
        target.forEach((value, key) =&gt; {
            cloneTarget.set(key, clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆对象和数组
    const keys = type === arrayTag ? undefined : Object.keys(target);
    forEach(keys || target, (value, key) =&gt; {
        if (keys) {
            key = value;
        }
        cloneTarget[key] = clone(target[key], map);
    });

    return cloneTarget;
}

module.exports = {
    clone
};
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/axios.html" class="prev">
        axios
      </a></span> <span class="next"><a href="/js/promise.html">
        promise
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a611df23.js" defer></script><script src="/assets/js/2.1379642d.js" defer></script><script src="/assets/js/19.0f8d6009.js" defer></script>
  </body>
</html>
